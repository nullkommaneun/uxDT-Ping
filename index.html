<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ultraschall Beacon Tester</title>
<style>
  body{font-family:Inter,Segoe UI,Arial;max-width:800px;margin:32px auto;padding:16px;color:#111}
  h1{font-size:1.4rem;margin-bottom:0.25rem}
  p.lead{margin-top:0;color:#444}
  label{display:block;margin-top:12px;font-weight:600}
  input[type="text"], input[type="number"], select{width:100%;padding:8px;margin-top:6px;border:1px solid #ccc;border-radius:6px}
  .row{display:flex;gap:12px}
  .col{flex:1}
  button{margin-top:12px;padding:10px 14px;border-radius:8px;border:0;background:#1f7bd3;color:#fff;font-weight:700;cursor:pointer}
  button.secondary{background:#6c757d}
  .status{margin-top:12px;padding:8px;border-radius:6px;background:#f1f5f9;color:#0b3b66}
  small.warn{display:block;margin-top:8px;color:#8a1f1f}
  footer{margin-top:18px;color:#666;font-size:0.9rem}
</style>
</head>
<body>
  <h1>Ultraschall-Beacon Tester</h1>
  <p class="lead">Playbook zum Aussenden kurzer Ultraschall-Bursts. Nur für Tests & Forschung verwenden.</p>

  <label for="freqs">Frequenzen (Hz), Komma-separiert</label>
  <input id="freqs" type="text" value="19000,19500,20000" />

  <div class="row">
    <div class="col">
      <label for="duration">Burst Dauer (ms)</label>
      <input id="duration" type="number" value="150" min="10" />
    </div>
    <div class="col">
      <label for="gap">Pause zwischen Bursts (ms)</label>
      <input id="gap" type="number" value="120" min="0" />
    </div>
  </div>

  <label for="gain">Lautstärke (0.0 - 1.0)</label>
  <input id="gain" type="number" step="0.01" min="0" max="1" value="0.25" />

  <label for="repeats">Wiederholungen</label>
  <input id="repeats" type="number" min="1" value="1" />

  <div style="display:flex;gap:8px;margin-top:12px">
    <button id="playSeq">▶ Play Sequence</button>
    <button id="playTone" class="secondary">▶ Play Einzelton</button>
    <button id="stop" class="secondary">■ Stop</button>
  </div>

  <div id="status" class="status">Status: Bereit</div>
  <small class="warn">Hinweis: Manche Geräte filtern >18 kHz; teste zuerst kurz und achte auf Tiere.</small>

  <footer>
    Diese Seite erzeugt sinusförmige Töne via WebAudio API. Nur lokal ausführen. Für erweiterte Muster/ID-Codierung kann ich das Pattern automatisch erstellen.
  </footer>

<script>
(() => {
  let ctx = null;
  let playingOscillators = [];
  let stopRequested = false;

  const $ = id => document.getElementById(id);
  const status = txt => { $('status').textContent = 'Status: ' + txt; };

  function ensureCtx() {
    if (!ctx || ctx.state === 'closed') {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return ctx;
  }

  // Safe ramp to avoid clicks
  function createOsc(freq, gainVal) {
    const c = ensureCtx();
    const o = c.createOscillator();
    const g = c.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, c.currentTime);
    o.connect(g);
    g.connect(c.destination);
    return {osc: o, gain: g};
  }

  async function playBurst(freq, durationMs, gainVal) {
    stopRequested = false;
    const c = ensureCtx();
    await c.resume();
    const {osc, gain} = createOsc(freq, gainVal);
    playingOscillators.push({osc,gain});
    const now = c.currentTime;
    // attack
    gain.gain.exponentialRampToValueAtTime(Math.max(0.0001, gainVal), now + 0.01);
    osc.start(now);
    const stopTime = now + durationMs/1000;
    // release quickly
    gain.gain.exponentialRampToValueAtTime(0.0001, stopTime + 0.01);
    setTimeout(()=> {
      try { osc.stop(); } catch(e){}
      // remove from list
      playingOscillators = playingOscillators.filter(x => x.osc !== osc);
    }, durationMs + 40);
  }

  async function playSequence(freqArray, durationMs, gapMs, gainVal, repeats=1) {
    stopRequested = false;
    const c = ensureCtx();
    await c.resume();
    status('Sequence läuft');
    for (let r=0; r<repeats; r++) {
      for (let i=0;i<freqArray.length;i++) {
        if (stopRequested) { status('Gestoppt'); return; }
        await playBurst(freqArray[i], durationMs, gainVal);
        // wait duration + gap (but since playBurst uses setTimeout for stop, we await the duration here)
        await new Promise(res => setTimeout(res, durationMs + gapMs));
      }
      // small gap between repeats
      if (r < repeats-1) await new Promise(res => setTimeout(res, 200));
    }
    status('Fertig');
  }

  // Single continuous tone for quick check
  function playContinuous(freq, gainVal) {
    stopRequested = false;
    const c = ensureCtx();
    c.resume().then(()=>{
      const {osc,gain} = createOsc(freq, gainVal);
      playingOscillators.push({osc,gain});
      const now = c.currentTime;
      gain.gain.exponentialRampToValueAtTime(Math.max(0.0001, gainVal), now + 0.01);
      osc.start();
      status('Einzelton läuft: ' + Math.round(freq) + ' Hz');
    }).catch(e => status('Audio start failed'));
  }

  function stopAll() {
    stopRequested = true;
    playingOscillators.forEach(({osc,gain})=>{
      try {
        const c = ensureCtx();
        const now = c.currentTime;
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.01);
        setTimeout(()=>{ try{osc.stop()}catch(e){} }, 30);
      } catch(e){}
    });
    playingOscillators = [];
    status('Gestoppt');
    // do NOT close context immediately; allow replay. If you want to fully close:
    // if (ctx) ctx.close();
  }

  // UI hooks
  $('playSeq').addEventListener('click', async ()=>{
    const freqs = $('freqs').value.split(',').map(s=>parseFloat(s.trim())).filter(Boolean);
    const dur = Math.max(10, parseInt($('duration').value) || 150);
    const gap = Math.max(0, parseInt($('gap').value) || 120);
    const gain = Math.min(1, Math.max(0, parseFloat($('gain').value) || 0.25));
    const reps = Math.max(1, parseInt($('repeats').value) || 1);

    if (!freqs.length) { status('Keine Frequenzen eingegeben'); return; }
    // user gesture already triggered the click -> resume will work
    try {
      await playSequence(freqs, dur, gap, gain, reps);
    } catch(e){
      console.error(e);
      status('Fehler beim Abspielen');
    }
  });

  $('playTone').addEventListener('click', ()=>{
    const freqs = $('freqs').value.split(',').map(s=>parseFloat(s.trim())).filter(Boolean);
    const gain = Math.min(1, Math.max(0, parseFloat($('gain').value) || 0.25));
    if (!freqs.length) { status('Keine Frequenzen eingegeben'); return; }
    playContinuous(freqs[0], gain);
  });

  $('stop').addEventListener('click', stopAll);

  // Keyboard shortcut: Space = stop
  window.addEventListener('keydown', (e)=>{ if (e.code === 'Space') { e.preventDefault(); stopAll(); } });

})();
</script>
</body>
</html>
